name: Production Database Backups
on:
  schedule:
    - cron: '0 6 * * *'      # Daily
    - cron: '0 8 1 * *'      # Monthly
    - cron: '0 * * * *'      # Hourly
    - cron: '0 20 * * 5'     # Weekly Summary
  workflow_dispatch:
    inputs:
      backup_type:
        description: 'Tipo de backup'
        required: true
        default: 'daily'
        type: choice
        options: [daily, monthly, hourly, weekly-summary]

env:
  NODE_VERSION: '20'

jobs:
  backup:
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      - name: Install PostgreSQL 17 client
        run: |
          sudo sh -c 'echo "deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" > /etc/apt/sources.list.d/pgdg.list'
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -
          sudo apt-get update
          sudo apt-get install -y postgresql-client-17
          echo "/usr/lib/postgresql/17/bin" >> $GITHUB_PATH
      - name: Install dependencies
        run: npm install --no-save googleapis @sendgrid/mail google-auth-library
      - name: Create and Run Backup Script
        env:
          # Pasamos el input manual. Si es null, el script de Node decidirÃ¡ por horario
          MANUAL_TYPE: ${{ github.event.inputs.backup_type }}
          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_DRIVE_FOLDER_ID_DAILY: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID_DAILY }}
          GOOGLE_DRIVE_FOLDER_ID_MONTHLY: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID_MONTHLY }}
          GOOGLE_DRIVE_FOLDER_ID_HOURLY: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID_HOURLY }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          FROM_EMAIL: ${{ secrets.SENDGRID_FROM_EMAIL }}
          NOTIFICATION_EMAIL: ${{ secrets.BACKUP_NOTIFICATION_EMAIL }}
        run: |
          cat > backup.mjs << 'EOF'
          import { google } from 'googleapis';
          import { exec } from 'child_process';
          import { createReadStream, unlinkSync, existsSync } from 'fs';
          import { promisify } from 'util';
          import sgMail from '@sendgrid/mail';
          const execAsync = promisify(exec);

          const { 
            MANUAL_TYPE, DATABASE_URL, GOOGLE_SERVICE_ACCOUNT_JSON, 
            GOOGLE_DRIVE_FOLDER_ID_DAILY, GOOGLE_DRIVE_FOLDER_ID_MONTHLY, 
            GOOGLE_DRIVE_FOLDER_ID_HOURLY, SENDGRID_API_KEY, 
            FROM_EMAIL, NOTIFICATION_EMAIL 
          } = process.env;

          sgMail.setApiKey(SENDGRID_API_KEY);

          // LÃ“GICA DE DETECCIÃ“N AUTOMÃTICA
          let type = MANUAL_TYPE;
          if (!type) {
            const now = new Date();
            const hour = now.getUTCHours();
            const day = now.getUTCDay(); // 5 es viernes
            const date = now.getUTCDate();
            
            if (hour === 20 && day === 5) type = 'weekly-summary';
            else if (hour === 8 && date === 1) type = 'monthly';
            else if (hour === 6) type = 'daily';
            else type = 'hourly';
          }

          const RETENTION = { daily: 30, monthly: 12, hourly: 48 };

          async function sendAlert(error) {
            await sgMail.send({
              to: NOTIFICATION_EMAIL,
              from: FROM_EMAIL,
              subject: `ðŸš¨ ERROR: Backup Fallido (${type})`,
              html: `<div style="font-family:sans-serif; border:2px solid red; padding:20px;">
                      <h2 style="color:red;">El backup ha fallado tras 3 intentos</h2>
                      <p><b>Tipo:</b> ${type}</p>
                      <p><b>Error detectado:</b> ${error}</p>
                    </div>`
            });
          }

          async function sendStyledSummary(data) {
            const htmlContent = `
            <div style="background-color: #1a1a1a; color: #ffffff; padding: 20px; font-family: sans-serif; border-radius: 8px; max-width: 800px;">
              <h2 style="color: #4caf50;">ðŸ“Š SimTree Weekly Backup Summary</h2>
              <table style="width: 100%; border-collapse: collapse; margin-top: 20px; color: #e0e0e0;">
                <thead>
                  <tr style="background-color: #333333; text-align: left;">
                    <th style="padding: 12px; border: 1px solid #444;">Type</th>
                    <th style="padding: 12px; border: 1px solid #444;">Total Backups</th>
                    <th style="padding: 12px; border: 1px solid #444;">Storage Used</th>
                  </tr>
                </thead>
                <tbody>
                  ${data.map(row => `
                    <tr>
                      <td style="padding: 12px; border: 1px solid #444;">${row.type}</td>
                      <td style="padding: 12px; border: 1px solid #444;">${row.count}</td>
                      <td style="padding: 12px; border: 1px solid #444;">${row.size}</td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              <p style="margin-top: 25px; font-weight: bold;">System status: âœ… Operational</p>
            </div>`;
            await sgMail.send({ to: NOTIFICATION_EMAIL, from: FROM_EMAIL, subject: `SimTree Weekly Backup Summary`, html: htmlContent });
          }

          const auth = new google.auth.GoogleAuth({ credentials: JSON.parse(GOOGLE_SERVICE_ACCOUNT_JSON), scopes: ['https://www.googleapis.com/auth/drive'] });
          const drive = google.drive({ version: 'v3', auth });

          async function mainTask() {
            if (type === 'weekly-summary') {
              const summaryData = [];
              const folders = [{ t: 'Daily', id: GOOGLE_DRIVE_FOLDER_ID_DAILY }, { t: 'Monthly', id: GOOGLE_DRIVE_FOLDER_ID_MONTHLY }, { t: 'Hourly', id: GOOGLE_DRIVE_FOLDER_ID_HOURLY }];
              for (const f of folders) {
                const res = await drive.files.list({ q: `'${f.id}' in parents and trashed=false`, fields: 'files(size)', supportsAllDrives: true, includeItemsFromAllDrives: true });
                const files = res.data.files || [];
                const totalSize = (files.reduce((a, b) => a + parseInt(b.size || 0), 0) / 1024 / 1024).toFixed(2);
                summaryData.push({ type: f.t, count: files.length, size: `${totalSize} MB` });
              }
              await sendStyledSummary(summaryData);
              return;
            }

            const folderId = type === 'hourly' ? GOOGLE_DRIVE_FOLDER_ID_HOURLY : (type === 'monthly' ? GOOGLE_DRIVE_FOLDER_ID_MONTHLY : GOOGLE_DRIVE_FOLDER_ID_DAILY);
            const fileName = `simtree-${type}-${new Date().toISOString().split('T')[0]}.sql.gz`;
            const filePath = `/tmp/${fileName}`;
            
            let cmd = `pg_dump "${DATABASE_URL}" --no-owner --no-acl`;
            if (type === 'hourly') cmd += ` -t wallets -t wallet_transactions -t purchased_esims`;
            
            await execAsync(`${cmd} | gzip -9 > ${filePath}`);
            await drive.files.create({ requestBody: { name: fileName, parents: [folderId] }, media: { mimeType: 'application/gzip', body: createReadStream(filePath) }, supportsAllDrives: true });

            // Limpieza profunda (trashed: true)
            const listRes = await drive.files.list({ q: `'${folderId}' in parents and trashed=false`, orderBy: 'createdTime asc', supportsAllDrives: true, includeItemsFromAllDrives: true });
            let files = listRes.data.files || [];
            const limit = RETENTION[type];
            if (files.length > limit) {
              const toTrash = files.slice(0, files.length - limit);
              for (const file of toTrash) {
                await drive.files.update({ fileId: file.id, requestBody: { trashed: true }, supportsAllDrives: true });
              }
            }
            if (existsSync(filePath)) unlinkSync(filePath);
          }

          // EJECUCIÃ“N CON 3 REINTENTOS
          async function execute() {
            let attempt = 1;
            while (attempt <= 3) {
              try {
                console.log(`>>> Intento ${attempt} para tipo: ${type}`);
                await mainTask();
                console.log(">>> âœ… Finalizado con Ã©xito");
                return;
              } catch (e) {
                console.error(`>>> Fallo en intento ${attempt}: ${e.message}`);
                if (attempt === 3) await sendAlert(e.message);
                else await new Promise(r => setTimeout(r, 15000));
                attempt++;
              }
            }
          }
          execute();
          EOF
          node backup.mjs
