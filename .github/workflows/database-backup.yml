name: Database Backup to Google Drive

on:
  schedule:
    # Daily full backup at 06:00 UTC (03:00 AM Buenos Aires)
    - cron: '0 6 * * *'
    # Incremental backup every 4 hours
    - cron: '0 */4 * * *'
  workflow_dispatch:
    inputs:
      backup_type:
        description: 'Type of backup to run'
        required: true
        default: 'daily'
        type: choice
        options:
          - daily
          - hourly

env:
  NODE_VERSION: '20'

jobs:
  backup:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: npm install --no-save googleapis

      - name: Determine backup type
        id: backup-type
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "type=${{ github.event.inputs.backup_type }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.schedule }}" == "0 6 * * *" ]; then
            echo "type=daily" >> $GITHUB_OUTPUT
          else
            echo "type=hourly" >> $GITHUB_OUTPUT
          fi

      - name: Create backup script
        run: |
          cat > backup.mjs << 'SCRIPT_EOF'
          import { google } from 'googleapis';
          import { exec } from 'child_process';
          import { createReadStream, statSync, unlinkSync } from 'fs';
          import { promisify } from 'util';

          const execAsync = promisify(exec);

          function sanitizeError(error) {
            let msg = error.message || String(error);
            msg = msg.replace(/postgresql:\/\/[^@]+@/gi, 'postgresql://***:***@');
            msg = msg.replace(/postgres:\/\/[^@]+@/gi, 'postgres://***:***@');
            msg = msg.replace(/password[=:][^\s&"']+/gi, 'password=***');
            return msg;
          }

          const BACKUP_TYPE = process.env.BACKUP_TYPE || 'daily';
          const DATABASE_URL = process.env.DATABASE_URL;
          const GOOGLE_CREDENTIALS = process.env.GOOGLE_SERVICE_ACCOUNT_JSON;
          const DAILY_FOLDER_ID = process.env.GOOGLE_DRIVE_FOLDER_ID;
          const HOURLY_FOLDER_ID = process.env.HOURLY_DRIVE_FOLDER_ID;
          const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;
          const NOTIFICATION_EMAIL = process.env.BACKUP_NOTIFICATION_EMAIL || 'admin@example.com';
          const FROM_EMAIL = process.env.SENDGRID_FROM_EMAIL || 'backups@example.com';

          // Critical tables for hourly backup
          const CRITICAL_TABLES = ['wallets', 'wallet_transactions', 'purchased_esims'];

          async function sendEmail(subject, body) {
            if (!SENDGRID_API_KEY) {
              console.log('SendGrid not configured, skipping email');
              return;
            }
            
            try {
              const response = await fetch('https://api.sendgrid.com/v3/mail/send', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${SENDGRID_API_KEY}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  personalizations: [{ to: [{ email: NOTIFICATION_EMAIL }] }],
                  from: { email: FROM_EMAIL },
                  subject: subject,
                  content: [{ type: 'text/html', value: body }]
                })
              });
              
              if (response.ok) {
                console.log('Email notification sent');
              } else {
                console.error('Email failed:', await response.text());
              }
            } catch (error) {
              console.error('Email error:', error.message);
            }
          }

          async function uploadToGoogleDrive(filePath, fileName, folderId) {
            const credentials = JSON.parse(GOOGLE_CREDENTIALS);
            
            const auth = new google.auth.GoogleAuth({
              credentials,
              scopes: ['https://www.googleapis.com/auth/drive.file']
            });
            
            const drive = google.drive({ version: 'v3', auth });
            
            console.log(`Uploading ${fileName} to Google Drive...`);
            
            const fileMetadata = {
              name: fileName,
              parents: [folderId]
            };
            
            const media = {
              mimeType: 'application/gzip',
              body: createReadStream(filePath)
            };
            
            const response = await drive.files.create({
              requestBody: fileMetadata,
              media: media,
              fields: 'id, name, size',
              supportsAllDrives: true
            });
            
            console.log(`Uploaded: ${response.data.id} (${response.data.size} bytes)`);
            return response.data;
          }

          async function manageRetention(folderId, maxFiles) {
            const credentials = JSON.parse(GOOGLE_CREDENTIALS);
            
            const auth = new google.auth.GoogleAuth({
              credentials,
              scopes: ['https://www.googleapis.com/auth/drive.file']
            });
            
            const drive = google.drive({ version: 'v3', auth });
            
            const listResponse = await drive.files.list({
              q: `'${folderId}' in parents and trashed=false`,
              fields: 'files(id, name, createdTime)',
              orderBy: 'createdTime desc',
              supportsAllDrives: true,
              includeItemsFromAllDrives: true
            });
            
            const files = listResponse.data.files || [];
            console.log(`Found ${files.length} backups in folder (max: ${maxFiles})`);
            
            if (files.length > maxFiles) {
              const toDelete = files.slice(maxFiles);
              console.log(`Deleting ${toDelete.length} old backups...`);
              
              for (const file of toDelete) {
                await drive.files.delete({ fileId: file.id, supportsAllDrives: true });
                console.log(`Deleted: ${file.name}`);
              }
            }
          }

          async function runBackup() {
            console.log(`Starting ${BACKUP_TYPE} backup...`);
            
            if (!DATABASE_URL) {
              throw new Error('DATABASE_URL not configured');
            }
            
            if (!GOOGLE_CREDENTIALS) {
              throw new Error('GOOGLE_SERVICE_ACCOUNT_JSON not configured');
            }
            
            const folderId = BACKUP_TYPE === 'hourly' ? HOURLY_FOLDER_ID : DAILY_FOLDER_ID;
            const maxRetention = BACKUP_TYPE === 'hourly' ? 48 : 14;
            
            if (!folderId) {
              throw new Error(`${BACKUP_TYPE === 'hourly' ? 'HOURLY_DRIVE_FOLDER_ID' : 'GOOGLE_DRIVE_FOLDER_ID'} not configured`);
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const prefix = BACKUP_TYPE === 'hourly' ? 'simtree-hourly-backup' : 'simtree-backup';
            const fileName = `${prefix}-${timestamp}.sql.gz`;
            const filePath = `/tmp/${fileName}`;
            
            // Build pg_dump command
            let pgDumpCmd = `pg_dump "${DATABASE_URL}"`;
            
            if (BACKUP_TYPE === 'hourly') {
              const tableArgs = CRITICAL_TABLES.map(t => `--table=${t}`).join(' ');
              pgDumpCmd = `pg_dump ${tableArgs} "${DATABASE_URL}"`;
            }
            
            const fullCmd = `${pgDumpCmd} | gzip -9 > ${filePath}`;
            
            console.log(`Running pg_dump for ${BACKUP_TYPE} backup...`);
            await execAsync(fullCmd);
            
            const stats = statSync(filePath);
            console.log(`Backup created: ${fileName} (${(stats.size / 1024 / 1024).toFixed(2)} MB)`);
            
            // Upload to Google Drive
            const uploadResult = await uploadToGoogleDrive(filePath, fileName, folderId);
            
            // Cleanup local file
            unlinkSync(filePath);
            
            // Manage retention
            await manageRetention(folderId, maxRetention);
            
            // Send success email
            const driveLink = `https://drive.google.com/file/d/${uploadResult.id}/view`;
            await sendEmail(
              `✅ ${BACKUP_TYPE.charAt(0).toUpperCase() + BACKUP_TYPE.slice(1)} Backup Successful`,
              `
                <h2>Database Backup Completed</h2>
                <p><strong>Type:</strong> ${BACKUP_TYPE}</p>
                <p><strong>File:</strong> ${fileName}</p>
                <p><strong>Size:</strong> ${(stats.size / 1024 / 1024).toFixed(2)} MB</p>
                <p><strong>Time:</strong> ${new Date().toISOString()}</p>
                <p><a href="${driveLink}">View in Google Drive</a></p>
              `
            );
            
            console.log('✅ Backup completed successfully');
            return { success: true, fileName, size: stats.size, driveFileId: uploadResult.id };
          }

          runBackup()
            .then(result => {
              console.log('Backup result:', JSON.stringify(result, null, 2));
              process.exit(0);
            })
            .catch(async error => {
              const safeError = sanitizeError(error);
              console.error('❌ Backup failed:', safeError);
              
              await sendEmail(
                '❌ Database Backup Failed',
                `
                  <h2>Database Backup Failed</h2>
                  <p><strong>Type:</strong> ${BACKUP_TYPE}</p>
                  <p><strong>Error:</strong> ${safeError}</p>
                  <p><strong>Time:</strong> ${new Date().toISOString()}</p>
                `
              );
              
              process.exit(1);
            });
          SCRIPT_EOF

      - name: Run backup
        env:
          BACKUP_TYPE: ${{ steps.backup-type.outputs.type }}
          DATABASE_URL: ${{ secrets.PROD_DATABASE_URL }}
          GOOGLE_SERVICE_ACCOUNT_JSON: ${{ secrets.GOOGLE_SERVICE_ACCOUNT_JSON }}
          GOOGLE_DRIVE_FOLDER_ID: ${{ secrets.GOOGLE_DRIVE_FOLDER_ID }}
          HOURLY_DRIVE_FOLDER_ID: ${{ secrets.HOURLY_DRIVE_FOLDER_ID }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_FROM_EMAIL: ${{ secrets.SENDGRID_FROM_EMAIL }}
          BACKUP_NOTIFICATION_EMAIL: ${{ secrets.BACKUP_NOTIFICATION_EMAIL }}
        run: node backup.mjs
