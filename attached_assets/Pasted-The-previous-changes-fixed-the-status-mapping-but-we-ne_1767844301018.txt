The previous changes fixed the status mapping, but we need to handle the null-timestamp edge case and unit precision to ensure the UI updates correctly. Please apply these specific technical adjustments:1. Robust Timestamp Fallback (Crucial):In the webhook handler, locate where activationDate is assigned before updating schema.employees.Change: Use a null-coalescing check for the provider timestamps.Code Logic: ```typescriptconst providerTime = content?.activateTime || content?.installationTime;const activationDate = (providerTime && providerTime !== 'null') ? new Date(providerTime) : new Date();This ensures that when an 'ONBOARD' status arrives without a timestamp, the employee's planStartDate is set to 'now' instead of null.2. Standardize Data Conversion Constant:Throughout the webhook handler, replace any dynamic byte-to-GB math with the constant 1073741824 ($1024^3$).When calculating updateData.dataUsed, ensure you are using .toFixed(4) on the result to match the string/decimal format expected by the database schema.3. Ensure Atomic Metadata Merge:Verify that the metadata update uses a deep merge or a spread of the existing esim.metadata.Requirement: We must preserve the iccid and lpa (QR code data) already in the metadata while adding the new syncedAt and providerStatus: "ONBOARD" fields.4. Forced SSE Event Payload:Ensure the emitEvent call explicitly includes the activationDate.toISOString(). The frontend needs this specific field to trigger the transition from the 'Pending/QR' view to the 'Active Data' view."What this solves technically:UI Sync: The frontend often waits for a planStartDate to start the countdown timer. If the webhook saved the status as "activated" but left the date null, the UI might stay stuck in a loading state. This fix forces the timer to start "now."Data Integrity: Standardizing the constant to 1024^3 ensures that your "Data Depleted" logic (which triggers auto-renewal) calculates the remaining balance with 100% accuracy compared to the provider's dashboard.